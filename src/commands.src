// 
// Marinette's commands




////////////////////////////////////////////////////////////
// Any session type
////////////////////////////////////////////////////////////

command "help", ["h", "?"], Const.any, Messages.HelpEntryHelp, function(arguments)
    commands = Helps.indexes
    if arguments.len != 0 then commands = arguments

    foundHelps = {}

    for command in commands
        if Commands.indexes.indexOf(command) == null then
            for kv in Aliases
                if kv.value.indexOf(command) != null then
                    command = kv.key
                    break
                end if
            end for
            if Commands.indexes.indexOf(command) == null then
                continue
            end if
        end if
        if Aliases.indexes.indexOf(command) != null then 
            aliases = Aliases[command]
            commands = [command] + aliases
        else
            commands = [command]
        end if
        commands = commands.join(", ")
        categories = Messages.HelpUndeterminedDescription
        args = Messages.HelpNoArguments
        description = Messages.HelpUndeterminedDescription

        if Helps.indexes.indexOf(command) != null then
            help = Helps[command]
            parts = help.split(" - ")

            if parts.len == 1 then 
                description = parts[0]
            else if parts.len == 2 then
                categories = parts[0]
                description = parts[1]
            else if parts.len == 3 then
                categories = parts[0]
                args = parts[1]
                description = parts[2]
            end if
        end if
        
        help = {
            "commands": commands,
            "args": args,
            "description": description,
        }

        if foundHelps.indexes.indexOf(categories) == null then foundHelps[categories] = []
        foundHelps[categories].push(help)
    end for

    printCategories = function(categories)
        print(primary("<b><--"+categories+"--></b>"))
        for help in foundHelps[categories]
            print(primary(help.commands)+secondary(" - "+help.args+" - "+help.description))
        end for
    end function

    if foundHelps.len > 0 then 
        categories = removeDuplicates(foundHelps.indexes)
        for category in categories
            foundHelps[category].sort("commands")
        end for
        typePredicate = function(iItem, jItem)
            priority = {
                Messages.SessionTypeAny: "A"*32,
                Messages.SessionTypeHost: "A"*31+"B",
                Messages.SessionTypeShell: "A"*31+"C",
                Messages.SessionTypeComputer: "A"*31+"D",
                Messages.SessionTypeFile: "A"*31+"E",
                Messages.HelpCategoryPlugins: "A"*31+"F",
                Messages.HelpUndeterminedDescription: "A"*31+"G",
            }
            if priority.indexes.indexOf(iItem) == null then priority[iItem] = iItem
            if priority.indexes.indexOf(jItem) == null then priority[jItem] = jItem
            return priority[iItem] > priority[jItem]
        end function
        mergeSort(categories, @typePredicate)

        last = categories.pop
        for category in categories
            printCategories(category)
            print(" ")
        end for
        printCategories(last)
    else
        Console.error(Messages.ErrorNoHelpEntries)
    end if
end function


command "credits", [], Const.any, Messages.HelpEntryLicense, function(arguments)
    Conditions.arguments(arguments, 0)

    contributors = [
        "Kurouzu", "Joe Strout", "Clover", "Roupi",
        "Finko42", "Ariavne", "Guest", "Simonize", "Olipro", 
        "Volk", "Plu70", "Rocketorbit", "Darkie", "Ayecue", "Wyatt",
    ]

    print(primary(Messages.SpecialThanksAndCredits))
    print(" ")
    print(primary(contributors.join(", ")))
    print(" ")
    print(primary(Messages.YouAreAllAwesome+" <3"))
end function


command "exit", ["quit", "q"], Const.any, Messages.HelpEntryQuit, function(arguments)
    Conditions.arguments(arguments, 0)

    Console.log(Messages.LogThanksAndQuit)
    exit
end function


command "cls", ["clear"], Const.any, Messages.HelpEntryClear, function(arguments)
    Conditions.arguments(arguments, 0)

    clear_screen
end function


command "sessions", [], Const.any, Messages.HelpEntrySm, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    
    command = arguments.pull
    if "add".indexOf(command) == 0  and arguments.len != 0 then return Conditions.arguments(arguments, 1)
    if "delete".indexOf(command) == 0 and arguments.len == 0 then return Conditions.argumentsMoreThan(arguments, 1)
    if "use".indexOf(command) == 0 and arguments.len != 1 then return Conditions.arguments(arguments, 2)
    if "look".indexOf(command) == 0 and arguments.len != 0 then return Conditions.arguments(arguments, 1)

    if "add".indexOf(command) == 0 then
        SessionsHelpers.add(Intrinsics)
        Console.log(Messages.LogSuccessfullSessionsUpdate)
    else if "delete".indexOf(command) == 0 then
        shownIds = deepCopy(arguments)
        i = 0; while i < arguments.len; i = i + 1
            id = arguments[i-1]
            if id isa string or not SessionsHelpers.delete(id) then
                Console.error(Messages.ErrorIncorrectSessionId)
            else
                j = i-1; while j < arguments.len; j = j + 1
                    arguments[j-1] = arguments[j-1] - 1
                end while
                Console.log(Messages.LogSuccessfullSessionDeletion, {"ID": shownIds[i-1]})
            end if
        end while
    else if "use".indexOf(command) == 0 then
        id = arguments[0]
        if id isa string or not SessionsHelpers.get(id) then return Console.error(Messages.ErrorIncorrectSessionId)
        globals.Intrinsics = SessionsHelpers.get(id)
        Console.log(Messages.LogSuccessfullSessionLoad)
    else if "look".indexOf(command) == 0 then
        output = Messages.SmHeader
        i = 1
        while SessionsHelpers.get(i) != null
            intrinsics = SessionsHelpers.get(i)
            output = output+char(10)+(i)+" "+SessionsHelpers.generateSessionName(intrinsics)
            i = i + 1
        end while
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "theme", [], Const.any, Messages.HelpEntryTheme, function(arguments)
    Conditions.arguments(arguments, 0)
    
    asciiArt = [
        "  __  __          _          _   _       ",
        " |  \/  |__ _ _ _(_)_ _  ___| |_| |_ ___ ",
        " | |\/| / _` | '_| | ' \/ -_)  _|  _/ -_)",
        " |_|  |_\__,_|_| |_|_||_\___|\__|\__\___|",
        " ",
    ]
    Console.asciiArt(asciiArt)

    Console.log(randomString(40))
    Console.warning(randomString(40))
    Console.error(randomString(40))

    print(" ")
    table = [
        randomString(10)+" "+randomString(10)+" "+randomString(10)+" "+randomString(10),
        randomString(11)+" "+randomString(11)+" "+randomString(11)+" "+randomString(11),
        randomString(12)+" "+randomString(12)+" "+randomString(12)+" "+randomString(12),
    ].join(char(10))
    print(formatColumnsColored(table, Theme.miscPrimary, Theme.miscSecondary))
end function


command "hash", [], Const.any, Messages.HelpEntryHashcrack, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.crypto

    crypto = Libs.crypto
    
    Console.log(Messages.LogHashCracking)
    for md5hash in fmap(@str, arguments)
        name = md5hash
        toCrack = md5hash
        if md5hash.indexOf(":") != null then
            parts = md5hash.split(":")
            name = parts[0]
            toCrack = parts[1]
        end if
        
        result = decipherPassword(crypto, toCrack)
        if not result then
            Console.error(replaceF(Messages.ErrorUncrackableHash, {"HASH": name}))
        else
            Console.log(replaceF(Messages.LogSuccessfullHashCracking, {"HASH": name, "PASSWORD": result}))
        end if
    end for
end function


command "whois", ["wi"], Const.any, Messages.HelpEntryWhois, function(arguments)
    Conditions.network

    whoisOne = function(addr)
        router = getNetworkNode(addr)
        if not router then return Console.error(Messages.ErrorIncorrectNetworkAddress)
        addr = router.public_ip

        domain = getDomainName(addr)
        email = getDomainEmailAddress(addr)
        phone = getDomainPhoneNumber(addr)
        admin = getAdministrativeContact(addr)
        if not domain or not admin or not email or not phone then return Console.error(Messages.ErrorFailedWhoisLookup)
        Console.log(replaceF(Messages.LogWhoisLookup, {"ADDRESS": addr}))
        lines = [
            "<color="+Theme.miscPrimary+">"+Messages.WhoisDomain+" - <color="+Theme.miscSecondary+">"+domain,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisEmail+" - <color="+Theme.miscSecondary+">"+email,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisPhoneNumber+" - <color="+Theme.miscSecondary+">"+phone,
            "<color="+Theme.miscPrimary+">"+Messages.WhoisAdministrator+" - <color="+Theme.miscSecondary+">"+admin,
        ]
        if whois(addr).indexOf("[Neurobox Network]") != null then lines.push(primary("[Neurobox Network]"))
        print(lines.join(char(10)))
    end function

    if arguments.len == 0 then
        whoisOne(getNetworkNode.public_ip)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            whoisOne(path)
            print(" ")
        end for
        whoisOne(last)
    end if
end function


command "meow", ["mpm"], Const.any, Messages.HelpEntryMeow, function(arguments)
    Conditions.argumentsMoreThan(arguments, 1)
    Conditions.network
    Conditions.apt
    
    fd = Intrinsics.file
    apt = Libs.apt
    command = str(arguments.pull)

    if "add".indexOf(command) == 0 then
        for repo in fmap(@str, arguments)
            parts = repo.split(":")
            if parts.len > 2 then return Console.error(Messages.ErrorIncorrectRepositoryAddress)
            
            address = parts[0]
            port = 1542
            if parts.len == 2 then port = parts[1].to_int
            
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            if not port isa number then return Console.error(Messages.ErrorCouldNotAccessSuchPort)

            result = apt.add_repo(address, port)
            if result and result isa string then
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "add_repo", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullRepositoryAddition, {"ADDRESS": address, "PORT": port}))
            end if
        end for
    else if "delete".indexOf(command) == 0 then
        for address in fmap(@str, arguments)
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            result = apt.del_repo(address)
            if result and result isa string then 
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "del_repo", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullRepositoryDeletion, {"ADDRESS": address}))
            end if
        end for
    else if "download".indexOf(command) == 0 then
        apt.update
        for package in fmap(@str, arguments)
            result = apt.install(package)
            if result and result isa string then
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "install", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogSuccessfullPackageInstallation, {"PACKAGE": package}))
            end if
        end for
    else if "look".indexOf(command) == 0 then
        apt.update
        for address in fmap(@str, arguments)
            router = getNetworkNode(address)
            if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
            address = router.public_ip

            result = apt.show(address)
            if result.indexOf(" repository not found") then 
                Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "show", "ERROR": result}))
            else
                Console.log(replaceF(Messages.LogContentsOfRepository, {"ADDRESS": address}))
                lines = result.split(char(10))
                lines.pop
                for line in lines
                    print("<color="+Theme.miscPrimary+">"+line)
                end for
            end if
        end for
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "pktmon", [], Const.any, Messages.HelpEntryPktmon, function(arguments)
    Conditions.argumentsFewerThan(arguments, 2)
    Conditions.network
    Conditions.metaxploit

    packets = 1
    metaxploit = Libs.metaxploit

    if arguments.len == 1 then packets = arguments[0]
    if not packets isa number then return Console.error(Messages.ErrorUnknownArguments)

    Console.log(Messages.LogStartingSniffing)
    i = 0; while i < packets; i = i + 1
        desyncFix
        result = metaxploit.sniffer(true)
        if not result then return Console.error(Messages.ErrorUnknown)

        lines = result.trim.split(char(10))
        lines = lines[2:]

        source = lines.pull.replace("<b>Source:</b> ", "")
        destination = lines.pull.replace("<b>Destination:</b> ", "")
        port = lines.pull.replace("<b>Protocol:</b> ", "")
        user = escape(lines.pull.replace("<b>USER:</b> ", ""))
        password = lines.join("\n")

        if password.indexOf("<b>PASSWORD[encrypted]:</b> ") == 0 then
            prefix = "O"
            password = password["<b>PASSWORD[encrypted]:</b> ".len:]
        else
            prefix = "X"
            password = password["<b>PASSWORD:</b> ".len:]
        end if

        password = escape(password)
        Console.log(prefix+": "+destination+":"+port+" <- "+source+" - "+user+"@"+password)
    end while
end function


// 
// Thanks Ariavne for allowing me to use their nickname as a tool name <3
command "ariadne", ["aria"], Const.any, Messages.HelpEntryAriadne, function(arguments)
    Conditions.metaxploit

    fd = Intrinsics.file
    metaxploit = Libs.metaxploit
    
    while fd.parent
        fd = fd.parent
    end while

    Console.log(Messages.LogSearchingForLocalLibraries)
    metalibs = []
    files = [] + fd.get_folders + fd.get_files
    while files.len > 0
        fd = files.pull
        if fd.is_folder then 
            files = fd.get_folders + fd.get_files + files
            continue
        end if

        if not fd.is_binary then continue
        metalib = metaxploit.load(fd.path)
        if not metalib then continue
        isAlreadyFound = false
        for foundLib in metalibs
            if foundLib.lib_name == metalib.lib_name and foundLib.version == metalib.version then
                isAlreadyFound = true
                break
            end if
        end for
        if not isAlreadyFound then metalibs.push(metalib)
    end while
    
    Console.log(Messages.LogScanningLocalLibraries, {"AMOUNT": metalibs.len})
    exploits = []
    for metalib in metalibs
        memory = scanLibrary(metaxploit, metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, metalib, address)
            exploits.push({"metalib": metalib, "address": address, "vulners": vulners})
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + fmap(@str, arguments)
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                result = bufferOverflow(exploit.metalib, exploit.address, vulner.value, ofArg)
                if result == null then continue
                object = result
                result = {
                    "publicAddr": Intrinsics.publicAddress,
                    "localAddr": Intrinsics.localAddress,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "nemesis", ["ns"], Const.any, Messages.HelpEntryNemesis, function(arguments)
    Conditions.argumentsMoreThan(arguments, 2)
    Conditions.network
    Conditions.metaxploit

    metaxploit = Libs.metaxploit

    addr = str(arguments.pull)
    argLocAddr = str(arguments.pull)
    argPort = arguments.pull
    ofArgs = [null]

    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    ofArgs = ofArgs + fmap(@str, arguments) + router.devices_lan_ip

    targets = []
    if isNodeLocallyAccessible(router) then
        for port in getNetworkPorts(addr)
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.local.get_lan_ip,
                "ip": port.local.get_lan_ip,
                "port": port.local.port_number,
            }
            targets.push(target)
        end for
        for localAddr in router.devices_lan_ip
            node = null
            isRouter = false
            if isNodeLocallyAccessible(router) then
                node = getNetworkNode(localAddr)
                if node then isRouter = true
            end if
            if isRouter then
                ofArgs = ofArgs + node.devices_lan_ip
                target = {
                    "publicAddr": node.public_ip,
                    "localAddr": localAddr,
                    "ip": localAddr,
                    "port": 0,
                }
                targets.push(target)
            end if
        end for
    else
        for port in getNetworkPorts(addr)
            if not port.public then continue
            target = {
                "publicAddr": router.public_ip,
                "localAddr": port.public.get_lan_ip,
                "ip": router.public_ip,
                "port": port.public.port_number,
            }
            targets.push(target)
        end for
        target = {
            "publicAddr": router.public_ip,
            "localAddr": router.local_ip,
            "ip": router.public_ip,
            "port": 0,
        }
        targets.push(target)
    end if
    targets = removeDuplicates(targets)
    ofArgs = removeDuplicates(ofArgs)

    libraries = []
    for target in targets
        if "all".indexOf(argLocAddr) != 0 and target.localAddr != argLocAddr then continue
        if "all".indexOf(argPort) != 0 and target.port != argPort then continue
        netSession = metaxploit.net_use(target.ip, target.port)
        if not netSession then continue
        metalib = netSession.dump_lib
        library = {
            "publicAddr": target.publicAddr,
            "localAddr": target.localAddr,
            "port": target.port,
            "metalib": metalib,
        }
        libraries.push(library)
    end for

    Console.log(Messages.LogScanningRemoteLibraries, {"AMOUNT": libraries.len})
    exploits = []
    for library in libraries
        memory = scanLibrary(metaxploit, library.metalib)
        for address in memory
            vulners = scanMemoryAddress(metaxploit, library.metalib, address)
            exploit = {
                "publicAddr": library.publicAddr,
                "localAddr": library.localAddr,
                "port": library.port,
                "metalib": library.metalib,
                "address": address,
                "vulners": vulners,
            }
            exploits.push(exploit)
        end for
    end for

    if exploits.len == 0 then return Console.error(Messages.ErrorNoExploitsInScannedLibraries)
    
    Console.log(Messages.LogExploitingVulnerabilities)
    results = []
    for exploit in exploits
        for vulner in exploit.vulners
            ofArgs = [null]
            if arguments.len > 0 then ofArgs = ofArgs + fmap(@str, arguments)
            ofArgs = removeDuplicates(ofArgs)
            for ofArg in ofArgs
                result = bufferOverflow(exploit.metalib, exploit.address, vulner.value, ofArg)
                if result == null then continue
                object = result
                result = {
                    "publicAddr": exploit.publicAddr,
                    "localAddr": exploit.localAddr,
                    "port": exploit.port,
                    "metalib": exploit.metalib,
                    "address": exploit.address,
                    "vulner": vulner,
                    "ofArg": null,
                    "object": object,
                }
                if ofArg != null then result.ofArg = ofArg
                results.push(result)
            end for
        end for
    end for

    if results.len == 0 then return Console.error(Messages.ErrorNoVulnerabilitiesInLibraries)

    Console.log(Messages.LogAddingNewSessions)
    for result in results
        object = result.object
        type = typeof(object)

        if object isa string or object isa number then continue

        intrinsics = deepCopy(Intrinsics)
        intrinsics.shell = null
        intrinsics.computer = null
        intrinsics.file = null
        intrinsics.publicAddress = result.publicAddr
        intrinsics.localAddress = result.localAddr
        intrinsics.port = result.port
        intrinsics.isConnectionRemote = true

        if type == "shell" then
            intrinsics.shell = object
            intrinsics.computer = intrinsics.shell.host_computer
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "computer" then
            intrinsics.computer = object
            intrinsics.file = intrinsics.computer.File("/")
        else if type == "file" then
            fd = object
            while fd.parent
                fd = fd.parent
            end while
            intrinsics.file = fd
        end if

        if result.ofArg != null and is_valid_ip(result.ofArg) then intrinsics.localAddress = result.ofArg

        SessionsHelpers.add(intrinsics)
    end for

    Console.log(Messages.LogCompilingExploitResults)
    outputs = {}
    for result in results
        library = result.metalib.lib_name
        version = result.metalib.version
        address = result.address
        vulner = result.vulner.value
        ofArg = ""
        object = result.object
        type = typeof(object)
        if result.ofArg then ofArg = result.ofArg

        key = [library,version,ofArg].join(" ")
        if outputs.indexes.indexOf(key) == null then
            outputs[key] = [address,vulner,type].join(" ")
        else
            outputs[key] = outputs[key]+char(10)+[address,vulner,type].join(" ")
        end if
    end for

    if outputs.len == 0 then return Console.error(Messages.ErrorNoUsefullExploits)

    Console.log(Messages.LogUsefullExploits)
    counter = 0
    for kv in outputs
        Console.log(Messages.LogVulnerabilitesIn, {"LIBRARY": kv.key})
        output = Messages.ExploitsHeader+char(10)+kv.value

        lines = output.split(char(10))
        typePredicate = function(iItem, jItem)
            priority = {
                "shell": 0,
                "computer": 1,
                "file": 2, 
                "string": 3,
                "number": 4,
            }
            iType = iItem.split(" ")[2]
            jType = jItem.split(" ")[2]
            return priority[iType] > priority[jType]
        end function
        mergeSort(lines, @typePredicate, 1)
        
        output = lines.join(char(10))
        print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))

        counter = counter + 1
        if counter != outputs.len then print(" ")
    end for

    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "wificrack", [], Const.any, Messages.HelpEntryNetcrack, function(arguments)
    Conditions.arguments(arguments, 2)
    Conditions.crypto

    crypto = Libs.crypto
    iface = str(arguments[0])
    id = arguments[1]

    if not isExistingWirelessInterface(Intrinsics.computer, iface) then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = getNetworksSortedByPower(Intrinsics.computer, iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    if not id isa number or id > networks.len then return Console.error(Messages.ErrorIncorrectNetworkId)

    network = networks[id-1].split(" ")
    bssid = network[0]
    pwr = network[1].replace("%", "").to_int
    essid = network[2]
    acks = ceil(300000 / pwr)

    Console.log(Messages.LogStartingMonitorMode)
    result = crypto.airmon("start", iface)
    if result isa string then
        crypto.airmon("stop", iface)
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "airmon", "ERROR": result}))
    end if

    Console.log(replaceF(Messages.LogAireplayingOn, {"ESSID": essid, "ACKS": acks}))
    result = crypto.aireplay(bssid, essid, acks)
    if result isa string then
        crypto.airmon("stop", iface)
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "aireplay", "ERROR": result}))
    end if

    desyncFix
    Console.log(Messages.LogAircrackingTheHandshake)
    password = crypto.aircrack(current_path+"/file.cap")

    Console.log(Messages.LogStoppingMonitorMode)
    crypto.airmon("stop", iface)

    if not password then
        return Console.error(Messages.ErrorFailedPasswordCrack)
    else
        return Console.log(replaceF(Messages.LogSuccessfullPasswordCrack, {"ESSID": essid, "ID": id, "PASSWORD": password}))
    end if
end function


command "string", ["str"], Const.any, Messages.HelpEntryString, function(arguments)
    Conditions.arguments(arguments, 1)

    length = arguments[0]
    if not length isa number or length < 1 then return Console.error(Messages.ErrorUnknownArguments)

    Console.log(randomString(length))
end function


command "md5", [], Const.any, Messages.HelpEntryMd5, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    for arg in fmap(@str, arguments)
        Console.log(arg+" -> "+md5(arg))
    end for
end function




////////////////////////////////////////////////////////////
// Host session type
////////////////////////////////////////////////////////////

command "systeminfo", ["si"], Const.host, Messages.HelpEntrySysinf, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    shell = get_shell
    computer = shell.host_computer

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLocalSystem+"-->")
    if user_bank_number then bank = user_bank_number else bank = error(Messages.SysInfUnavailable)
    if user_mail_address then mail = user_mail_address else mail = error(Messages.SysInfUnavailable)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfUserName+" <color="+Theme.miscSecondary+">- "+active_user)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHostName+" <color="+Theme.miscSecondary+">- "+computer.get_name)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfHomePath+" <color="+Theme.miscSecondary+">- "+home_dir)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfBankLogin+" <color="+Theme.miscSecondary+">- "+bank)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfEmail+" <color="+Theme.miscSecondary+">- "+mail)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfProgramPath+" <color="+Theme.miscSecondary+">- "+program_path)
    print("")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfNetwork+"-->")
    bssid = error(Messages.SysInfUnavailable)
    essid = error(Messages.SysInfUnavailable)
    kernel = error(Messages.SysInfUnavailable)
    localIp = error(Messages.SysInfUnavailable)
    publicIp = error(Messages.SysInfUnavailable)
    deviceIp = error(Messages.SysInfUnavailable)
    if computer.is_network_active then
        router = getNetworkNode
        bssid = router.bssid_name
        essid = router.essid_name
        kernel = router.kernel_version
        localIp = router.local_ip
        publicIp = router.public_ip
        deviceIp = computer.local_ip
    end if
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfMacAddress+" <color="+Theme.miscSecondary+">- "+bssid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfNetworkName+" <color="+Theme.miscSecondary+">- "+essid)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfKernelVersion+" <color="+Theme.miscSecondary+">- "+kernel)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfLocalAddress+" <color="+Theme.miscSecondary+">- "+localIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfPublicAddress+" <color="+Theme.miscSecondary+">- "+publicIp)
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDeviceAddress+" <color="+Theme.miscSecondary+">- "+deviceIp)
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfLibraries+"-->")
    crypto = error(Messages.SysInfNotLoaded)
    apt = error(Messages.SysInfNotLoaded)
    metaxploit = error(Messages.SysInfNotLoaded)
    blockchain = error(Messages.SysInfNotLoaded)
    if Libs.indexes.indexOf("crypto") != null then crypto = Messages.SysInfLoaded
    if Libs.indexes.indexOf("apt") != null then apt = Messages.SysInfLoaded
    if Libs.indexes.indexOf("metaxploit") != null then metaxploit = Messages.SysInfLoaded
    if Libs.indexes.indexOf("blockchain") != null then blockchain = Messages.SysInfLoaded
    print("<color="+Theme.miscPrimary+">Crypto <color="+Theme.miscSecondary+">- "+crypto)
    print("<color="+Theme.miscPrimary+">Apt <color="+Theme.miscSecondary+">- "+apt)
    print("<color="+Theme.miscPrimary+">Metaxploit <color="+Theme.miscSecondary+">- "+metaxploit)
    print("<color="+Theme.miscPrimary+">Blockchain <color="+Theme.miscSecondary+">- "+blockchain)
    print(" ")

    print(primary("<b><--"+Messages.SysInfMainframe+"-->"))
    protocol = error(Messages.SysInfUnavailable)
    publicAddress = error(Messages.SysInfUnavailable)
    localAddress = error(Messages.SysInfUnavailable)
    port = error(Messages.SysInfUnavailable)
    credentials = error(Messages.SysInfUnavailable)
    connection = error(Messages.SysInfUnavailable)
    patches = error(Messages.SysInfUnavailable)
    if Config.mainframe then
        if Mainframe.protocol then protocol = Mainframe.protocol
        if Mainframe.publicAddress then publicAddress = Mainframe.publicAddress
        if Mainframe.localAddress then localAddress = Mainframe.localAddress
        if Mainframe.port != null then port = Mainframe.port
        if Mainframe.credentials then credentials = Mainframe.credentials
        if Mainframe.shell then connection = Messages.SysInfAvailable
        if Config.patches.len > 0 then patches = Mainframe.patches.len+"/"+Config.patches.len
    end if
    print(primary(Messages.SysInfMainframeProtocol)+secondary(" - "+protocol))
    print(primary(Messages.SysInfPublicAddress)+secondary(" - "+publicAddress))
    print(primary(Messages.SysInfLocalAddress)+secondary(" - "+localAddress))
    print(primary(Messages.SysInfMainframePort)+secondary(" - "+port))
    print(primary(Messages.SysInfMainframeCredentials)+secondary(" - "+credentials))
    print(primary(Messages.SysInfMainframeConnection)+secondary(" - "+connection))
    print(primary(Messages.SysInfMainframePatches)+secondary(" - "+patches))
    print(" ")

    print("<color="+Theme.miscPrimary+"><b><--"+Messages.SysInfMiscellaneous+"-->")
    print("<color="+Theme.miscPrimary+">"+Messages.SysInfDateTime+" <color="+Theme.miscSecondary+">- "+current_date)
end function


command "reload", ["rl"], Const.host, Messages.HelpEntryReload, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.host

    RuntimeHelpers.makeNeccessaryRuntimeAssigns
    RuntimeHelpers.checkIfEverythingIsAssigned
end function


command "su", [], Const.host, Messages.HelpEntryUserchange, function(arguments)
    Conditions.arguments(arguments, 2)
    Conditions.host

    user = str(arguments[0])
    pass = str(arguments[1])
    
    shell = get_shell(user, pass)
    if not shell then
        Console.error(Messages.ErrorIncorrectUsernameOrPassword)
    else
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fd = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fd then return Console.error(Messages.ErrorCouldNotFindMyself)

        Intrinsics.shell = shell
        Intrinsics.computer = Intrinsics.shell.host_computer
        Intrinsics.file = Intrinsics.computer.File("/")
        
        RuntimeHelpers.startMarinette(shell, fd.path)
    end if
end function


command "netcat", ["ncat", "nc"], Const.host, Messages.HelpEntrySvcon, function(arguments)
    Conditions.arguments(arguments, 6)
    Conditions.host
    Conditions.network

    addr = str(arguments[0])
    locAddr = str(arguments[1])
    port = arguments[2]
    user = str(arguments[3])
    pass = str(arguments[4])
    svc = str(arguments[5])


    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    svcPort = getExactPort(addr, locAddr, port)
    if not svcPort then return Console.error(Messages.ErrorCouldNotAccessSuchPort)
    if not isNodeLocallyAccessible(router) and not svcPort.public then return Console.error(Messages.ErrorCouldNotAccessSuchPort)

    target = addr
    if isNodeLocallyAccessible(router) then target = locAddr else port = svcPort.public.port_number
    result = Intrinsics.shell.connect_service(target, port, user, pass, svc)
    if not result then return Console.error(Messages.ErrorConnectionFailed)
    if result isa string then return Console.error(Messages.ErrorStringGeneral, {"FUNC": "connect_service", "ERROR": result})
    if ["shell", "ftpshell"].indexOf(typeof(result)) == null then Console.error(Messages.ErrorConnectionUnknownShell)
    
    intrinsics = deepCopy(Intrinsics)
    intrinsics.shell = result
    intrinsics.computer = intrinsics.shell.host_computer
    intrinsics.file = intrinsics.computer.File("/")
    intrinsics.publicAddress = intrinsics.computer.public_ip
    intrinsics.localAddress = intrinsics.computer.local_ip
    intrinsics.port = port
    intrinsics.isConnectionRemote = true
    
    SessionsHelpers.add(intrinsics)
    Console.log(Messages.LogSuccessfullSessionsUpdate)
end function


command "addr", [], Const.host, Messages.HelpEntryRaddr, function(arguments)
    Conditions.argumentsFewerThan(arguments, 2)
    Conditions.host
    Conditions.network

    count = arguments.pull
    if count == null then count = 1
    if not count isa number then return Console.error(Messages.ErrorUnknownArguments)
    if count < 1 then return

    Console.log(Messages.LogGeneratingRandomAddresses)
    i = 0; while i < count; i = i + 1
        print("<color="+Theme.miscPrimary+">"+randomNetworkAddress+"</color>")
    end while
    Console.log(Messages.LogDoneGeneratingRandomAddresses)
end function


command "findservice", ["findsvc"], Const.host, Messages.HelpEntrySvcfind, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.argumentsFewerThan(arguments, 3)
    Conditions.host
    Conditions.network

    service = str(arguments[0])
    serviceVersion = null
    if arguments.len == 2 then serviceVersion = str(arguments[1])

    if "gateway".indexOf(service.lower) == 0 then service = Messages.ServiceNode

    while true
        ip = randomNetworkAddress
        router = getNetworkNode(ip)
        if service == Messages.ServiceNode then
            if not serviceVersion or (router.kernel_version == serviceVersion) then
                return Console.log(Messages.LogServiceFound, {"SERVICE": Messages.ServiceNode+" "+router.kernel_version, "ADDRESS":ip, "PORT": 0})
            end if
        else
            for port in router.used_ports
                info = router.port_info(port)
                if info.indexOf(service) != null then
                    if not serviceVersion or (serviceVersion and info.indexOf(serviceVersion) != null) then
                        return Console.log(Messages.LogServiceFound, {"SERVICE": info, "ADDRESS":ip, "PORT": port.port_number})
                    end if
                end if
            end for
        end if
        version = ""
        if serviceVersion then version = " "+serviceVersion
        Console.error(Messages.ErrorServiceNotFound, {"SERVICE": service+version, "ADDRESS": ip})
        desyncFix
    end while
end function


command "lib", [], Const.host, Messages.HelpEntryInspect, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.host
    Conditions.metaxploit

    metaxploit = Libs.metaxploit

    inspectOne = function(path)
        fd = iterateToPath(Intrinsics.file, path)

        metalib = null
        if fd then metalib = metaxploit.load(fd.path)
        if not metalib then return Console.error(Messages.ErrorIncorrectLibraryPath)

        object = null
        if fd then object = include_lib(fd.path)

        if not object then
            objectType = "library"
        else
            objectType = typeof(object).lower
            for removal in ["lib", "client"]
                objectType = objectType.replace(removal, "")
            end for
        end if

        Console.log(replaceF(Messages.LogLibraryAt, {"PATH": fd.path}))
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryType+" - <color="+Theme.miscSecondary+">"+objectType)
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryName+" - <color="+Theme.miscSecondary+">"+metalib.lib_name)
        print("<color="+Theme.miscPrimary+">"+Messages.InspectLibraryVersion+" - <color="+Theme.miscSecondary+">"+metalib.version)
    end function

    arguments = fmap(@str, arguments)
    last = arguments.pop
    for path in arguments
        inspectOne(path)
        print(" ")
    end for
    inspectOne(last)
end function


command "netscan", ["nesca"], Const.host, Messages.HelpEntryNesca, function(arguments)
    Conditions.host
    Conditions.network

    nescaOne = function(address)
        nodes = []

        router = getNetworkNode(address)
        if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)

        domain = getDomainName(address)

        portlessNodes = getPortlessNodes(address)
        if portlessNodes.len > 0 then
            Console.log(Messages.LogNescaNoPorts, {"DOMAIN": domain, "PUBADDR": router.public_ip, "LOCADDR": router.local_ip})
            for portlessAddress in portlessNodes
                print(secondary(portlessAddress))
            end for
        end if

        output = Messages.NescaFirewallHeader
        for rule in router.firewall_rules
            parts = rule.split(" ")
            action = parts[0]
            port = parts[1]
            source = parts[2]
            dest = parts[3]
            addr = router.local_ip
            output = output+char(10)+[port,action,source,dest,addr].join(" ")
        end for
        if output != Messages.NescaFirewallHeader then 
            Console.log(replaceF(Messages.LogNescaFirewallOn, {"DOMAIN": domain, "PUBADDR": router.public_ip, "LOCADDR": router.local_ip}))
            print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
        end if
        
        output = Messages.NescaHeaderNew
        for port in getNetworkPorts(address)
            public = "-"
            state = Messages.PortStateLocal
            if port.public then
                public = port.public.port_number
                state = Messages.PortStateClosed
                if not port.public.is_closed then state = Messages.PortStateOpened
            end if
            if port.local.get_lan_ip == router.local_ip and output.indexOf(Messages.ServiceNode) == null then output = output+char(10)+[Messages.ServiceNode,router.kernel_version,Messages.PortStateOpened,"0","0",router.local_ip].join(" ")
            output = output+char(10)+[router.port_info(port.local),state,public,port.local.port_number,port.local.get_lan_ip].join(" ")
        end for
        if output.indexOf(Messages.ServiceNode) == null then
            output = output.replace(Messages.NescaHeaderNew, [Messages.ServiceNode,router.kernel_version,Messages.PortStateOpened,"0","0",router.local_ip].join(" "))
            output = Messages.NescaHeaderNew+char(10)+output
        end if
        if output != Messages.NescaHeaderNew then 
            Console.log(replaceF(Messages.LogNescaOn, {"DOMAIN": domain, "PUBADDR": router.public_ip, "LOCADDR": router.local_ip}))
            print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
        end if
    end function

    if arguments.len == 0 then
        nescaOne(Intrinsics.publicAddress)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for address in arguments
            nescaOne(str(address))
            print(" ")
        end for
        nescaOne(last)
    end if
end function


command "mails", [], Const.host, Messages.HelpEntryMaildump, function(arguments)
    Conditions.arguments(arguments, 3)
    Conditions.host
    Conditions.network
    Conditions.crypto

    crypto = Libs.crypto

    addr = str(arguments[0])
    locAddr = str(arguments[1])
    port = arguments[2]

    router = getNetworkNode(addr)
    if not router then return Console.error(Messages.ErrorIncorrectNodeAddress)
    addr = router.public_ip
    if isNodeLocallyAccessible(router) then addr = router.local_ip

    smtpPort = getExactPort(addr, locAddr, port)
    if not smtpPort then return Console.error(Messages.ErrorCouldNotAccessSuchPort)
    if not isNodeLocallyAccessible(router) and not smtpPort.public then return Console.error(Messages.ErrorCouldNotAccessSuchPort)
    if router.port_info(smtpPort.local).indexOf("smtp") == null then return Console.error(replaceF(Messages.ErrorNoServiceOnPort, {"SERVICE": "smtp", "PORT": port}))

    target = addr
    if isNodeLocallyAccessible(router) then target = locAddr else port = smtpPort.public.port_number
    result = crypto.smtp_user_list(target, port)
    if result isa string then
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "smtp_user_list", "ERROR": result}))
    else if not result then 
        return Console.error(replaceF(Messages.ErrorInvulnerableService, {"SERVICE": "smtp"}))
    end if

    Console.log(replaceF(Messages.LogRegisteredUsersOn, {"DOMAIN": getDomainName(addr), "PUBADDR": router.public_ip, "LOCADDR": locAddr}))
    output = result.join(char(10))
    output = output.replace("email not found", "-")
    output = Messages.MaildumpHeader+char(10)+output
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function




////////////////////////////////////////////////////////////
// Shell and FtpShell session types
////////////////////////////////////////////////////////////

command "hostify", [], Const.shell, Messages.HelpEntryHostify, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.remote
    Conditions.shell(["shell"])
    Conditions.network

    Console.log(Messages.LogLookingForPermissivePathToUploadInto)
    fdPermissive = findPermissivePath(Intrinsics.file, "wx")
    if not fdPermissive then return Console.error(Messages.ErrorCouldNotFindPermissivePathToUploadInto)

    marinettePath = null
    fdMarinette = findMyself(Intrinsics.shell, Config.identificator, "--identify-marinette --password "+Var.password, true)
    if fdMarinette and fdMarinette.has_permission("x") then marinettePath = fdMarinette.path
    if not marinettePath then
        Console.log(Messages.LogLookingForMyself)
        // Now that I think of it - this is potentially a security vulnerability. Should be cautious.
        fdMarinette = findMyself(get_shell, Config.identificator, "--identify-marinette --password "+Var.password)
        if not fdMarinette then return Console.error(Messages.ErrorCouldNotFindMyself)
        
        if Libs.indexes.indexOf("metaxploit") != null then
            uploads = [fdMarinette.path] + loadLibraries(Libs.metaxploit, true).values
        else
            uploads = [fdMarinette.path] + loadLibraries(null, true).values
        end if

        Console.log(Messages.LogUploadingNeccessary)
        for upload in uploads
            hasFailed = false
            result = get_shell.scp(upload, fdPermissive.path, Intrinsics.shell)
            if result isa string then
                Console.error(Messages.ErrorStringGeneral, {"FUNC": "scp", "ERROR": result})
                hasFailed = true
            else if not result then
                Console.error(Messages.ErrorUnknown)
                hasFailed = true
            end if
            if hasFailed then
                Console.error("<i>"+upload+"</i> -/> <i>"+fdPermissive.path)
                if upload == fdMarinette.path then return
            else
                Console.log("<i>"+upload+"</i> --> <i>"+fdPermissive.path)
                if upload == fdMarinette.path then marinettePath = pathJoin([fdPermissive.path, fdMarinette.name])
            end if
        end for
    end if

    Intrinsics.isConnectionRemote = false
    RuntimeHelpers.startMarinette(Intrinsics.shell, marinettePath)
end function


command "cmd", [], Const.shell, Messages.HelpEntryConsole, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.shell(["shell"])

    Console.log(Messages.LogStartingInGameConsole)
    Intrinsics.shell.start_terminal
    exit
end function


command "start", [], Const.shell, Messages.HelpEntryRun, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.shell(["shell"])

    binaryPath = str(arguments.pull)
    binaryArgs = null
    if arguments.len > 0 then binaryArgs = fmap(@str, arguments).join(" ")

    fd = iterateToPath(Intrinsics.file, binaryPath)
    if not fd or not fd.is_binary then return Console.error(Messages.ErrorPathDoesntExistOrNotBinary)

    Console.log(Messages.LogRunningBinary)
    if not binaryArgs then
        result = Intrinsics.shell.launch(fd.path)
    else
        result = Intrinsics.shell.launch(fd.path, binaryArgs)
    end if

    if result isa string then
        Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "launch", "ERROR": result}))
    else if not result then
        Console.error(Messages.ErrorCouldNotLaunchBinary)
    end if
end function


command "scp", ["ftp"], Const.shell, Messages.HelpEntryScp, function(arguments)
    Conditions.arguments(arguments, 3)
    Conditions.remote

    command = str(arguments[0])
    path = str(arguments[1])
    dest = str(arguments[2])

    fdHost = get_shell.host_computer.File("/")
    if "download".indexOf(command) == 0 then
        source = iterateToPath(Intrinsics.file, path)
        dest = iterateToPath(fdHost, dest)

        shellSource = Intrinsics.shell
        computerSource = Intrinsics.computer
        fdSource = Intrinsics.file

        shellDest = get_shell
        computerDest = shellDest.host_computer
        fdDest = computerDest.File("/")
    else if "upload".indexOf(command) == 0 then
        source = iterateToPath(fdHost, path)
        dest = iterateToPath(Intrinsics.file, dest)

        shellSource = get_shell
        computerSource = shellSource.host_computer
        fdSource = computerSource.File("/")

        shellDest = Intrinsics.shell
        computerDest = Intrinsics.computer
        fdDest = Intrinsics.file
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
    
    if not source then return Console.error(Messages.ErrorSourcePathDoesNotExist)
    if not dest then return Console.error(Messages.ErrorDesinationPathDoesNotExist)

    result = sendFile(shellSource, computerSource, fdSource, source.path, dest.path, shellDest, computerDest, fdDest)
    if not result then return Console.error(Messages.ErrorFailedFileTransfer)
    Console.log(Messages.LogSuccessfullySentFile)
end function


command "make", [], Const.shell, Messages.HelpEntryMake, function(arguments)
    Conditions.argumentsMoreThan(arguments, 2)
    Conditions.argumentsFewerThan(arguments, 5)

    path = str(arguments.pull)
    dest = str(arguments.pull)
    size = arguments.pull
    allow = arguments.pull
    if allow == null then allow = 0

    fdSource = iterateToPath(Intrinsics.file, path)
    if not fdSource then return Console.error(Messages.ErrorSourcePathDoesNotExist)

    fdDest = iterateToPath(Intrinsics.file, dest)
    if not fdDest then return Console.error(Messages.ErrorDesinationPathDoesNotExist)

    if not size isa number then return Console.error(Messages.ErrorUnknownArguments)
    if [false, true].indexOf(allow) == null then return Console.error(Messages.ErrorUnknownArguments)

    Console.log(Messages.LogCompilingTheSource)

    result = Intrinsics.shell.build(fdSource.path, fdDest.path, allow)
    if result and result isa string then
        return Console.error(Messages.ErrorStringGeneral, {"FUNC": "build", "ERROR": result})
    else if result != "" then
        return Console.error(Messages.ErrorUnknown)
    end if

    sourceName = fdSource.name
    destName = fdSource.name.replace(".src", "")
    fd = iterateToPath(Intrinsics.file, pathJoin([fdDest.path, destName]))
    if not fd or not fd.is_binary then return Console.error(Messages.ErrorUnknown)
    fd.delete
    
    while true
        desyncFix
        
        newDestName = randomString(randomNumber(1, 8))
        newSourceName = newDestName+".src"

        fdSource = renameFile(fdSource, newSourceName)
        if not fdSource then return Console.error(Messages.ErrorUnknown)

        result = Intrinsics.shell.build(fdSource.path, fdDest.path, allow)
        if result and result isa string then
            return Console.error(Messages.ErrorStringGeneral, {"FUNC": "build", "ERROR": result})
        else if result != "" then
            return Console.error(Messages.ErrorUnknown)
        end if

        fd = iterateToPath(Intrinsics.file, pathJoin([fdDest.path, newDestName]))
        if not fd or not fd.is_binary then return Console.error(Messages.ErrorUnknown)

        if fd.size.to_int > size then
            desyncFix
            fd.delete
        else
            break
        end if
    end while

    results = [fdSource.rename(sourceName), fd.rename(destName)]
    for result in results
        if result and result isa string then
            return Console.error(Messages.ErrorStringGeneral, {"FUNC": "rename", "ERROR": result})
        else if result != "" then
            return Console.error(Messages.ErrorUnknown)
        end if
    end for

    Console.log(Messages.LogSuccessfullCompilation)
end function




////////////////////////////////////////////////////////////
// Computer session type
////////////////////////////////////////////////////////////

command "ipconfig", [], Const.computer, Messages.HelpEntryNetint, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.computer

    netdevices = Intrinsics.computer.network_devices.trim
    if netdevices == "" then netdevices = "- - -"

    Console.log(Messages.LogGettingNetworkInterfaces)
    output = Messages.NetintHeader+char(10)+netdevices
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "networks", [], Const.computer, Messages.HelpEntryNetlook, function(arguments)
    Conditions.arguments(arguments, 1)
    Conditions.computer

    iface = str(arguments[0])

    if not isExistingWirelessInterface(Intrinsics.computer, iface) then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = getNetworksSortedByPower(Intrinsics.computer, iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)

    Console.log(Messages.LogSurroundingNetworks)
    output = Messages.NetlookHeader
    i = 0; for network in networks; i = i + 1
        pwr = network.split(" ")[1].replace("%", "").to_int
        acks = ceil(300000 / pwr)
        output = output+char(10)+i+" "+network+" "+acks
    end for
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "connect", [], Const.computer, Messages.HelpEntryNetcon, function(arguments)
    Conditions.arguments(arguments, 3)
    Conditions.computer

    iface = str(arguments[0])
    id = arguments[1]
    password = str(arguments[2])

    if not isExistingWirelessInterface(Intrinsics.computer, iface) then return Console.error(Messages.ErrorIncorrectNetworkInterface)

    networks = getNetworksSortedByPower(Intrinsics.computer, iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    if not id isa number or id > networks.len then return Console.error(Messages.ErrorIncorrectNetworkId)
    id = id - 1

    network = networks[id].split(" ")
    bssid = network[0]
    essid = network[2]

    hasNetworkConnectionBefore = Intrinsics.computer.is_network_active
    result = Intrinsics.computer.connect_wifi(iface, bssid, essid, password)
    if result isa string then
        return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "connect_wifi", "ERROR": result}))
    else
        Console.log(replaceF(Messages.LogConnectedToEssidSuccessfully, {"ESSID": essid}))
    end if

    if Intrinsics.isConnectionRemote or hasNetworkConnectionBefore then return
    RuntimeHelpers.makeNeccessaryRuntimeAssigns
    RuntimeHelpers.checkIfEverythingIsAssigned(true)
end function


command "tasklist", [], Const.computer, Messages.HelpEntryTasklist, function(arguments)
    Conditions.arguments(arguments, 0)
    Conditions.computer

    lines = Intrinsics.computer.show_procs.split(char(10))
    tasks = lines[1:]
    if tasks.len == 0 then tasks = ["- - - - -"]
    
    Console.log(Messages.LogAllRunningTasks)
    output = Messages.TasklistHeader+char(10)+tasks.join(char(10))
    print(formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary))
end function


command "taskkill", [], Const.computer, Messages.HelpEntryTaskill, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    for pid in removeDuplicates(arguments)
        result = Intrinsics.computer.close_program(pid)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "close_program", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogSuccessfullyKilledTask)
        end if
    end for
end function


command "newtext", ["nt"], Const.computer, Messages.HelpEntryTextfile, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    textfileOne = function(path)
        fd = Intrinsics.file
        parts = path.split("/")
        fileName = parts.pop
        path = parts.join("/")
        if path != "" then fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        result = Intrinsics.computer.touch(fd.path, fileName)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "touch", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogFileHasBeenCreatedSuccessfully)
        end if
    end function

    for path in fmap(@str, arguments)
        textfileOne(path)
    end for
end function


command "newdir", ["nd"], Const.computer, Messages.HelpEntryDirectory, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)
    Conditions.computer

    directoryOne = function(path)
        fd = Intrinsics.file
        parts = path.split("/")
        fileName = parts.pop
        path = parts.join("/")
        if path != "" then fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        result = Intrinsics.computer.create_folder(fd.path, fileName)
        if result isa string then
            Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "create_folder", "ERROR": result}))
        else if not result then
            Console.error(Messages.ErrorUnknown)
        else
            Console.log(Messages.LogDirectoryHasBeenCreatedSuccessfully)
        end if
    end function

    for path in fmap(@str, arguments)
        directoryOne(path)
    end for
end function


command "netrandom", [], Const.computer, Messages.HelpEntryNetrandom, function(arguments)
    Conditions.argumentsMoreThan(arguments, 2)
    Conditions.computer

    iface = str(arguments.pull)
    credentials = removeDuplicates(fmap(@str, arguments))

    if not isExistingWirelessInterface(Intrinsics.computer, iface) then return Console.error(Messages.ErrorIncorrectNetworkInterface)
    networks = getNetworksSortedByPower(Intrinsics.computer, iface)
    if not networks then return Console.error(Messages.ErrorCouldNotGetNetworksList)
    
    incorrectCredentials = []
    for credential in credentials
        parts = credential.split(":")
        if parts.len != 2 then 
            incorrectCredentials.push(credential)
            continue
        end if

        id = parts[0].to_int
        password = parts[1]
        if not id isa number or id > networks.len then
            incorrectCredentials.push(credential)
            continue
        end if
        
        isConnected = connectWirelessNetworkById(Intrinsics.computer, iface, networks, id, password)
        if not isConnected then
            incorrectCredentials.push(credential)
            continue
        end if
    end for

    if incorrectCredentials then
        Console.error(Messages.ErrorFollowingCredentialsAreIncorrect, {"CREDENTIALS": incorrectCredentials.join(", ")})
        for credential in incorrectCredentials
            credentials.remove(credentials.indexOf(credential))
        end for
    end if

    if credentials.len == 0 then return

    credential = null
    while true
        while credentials[0] == credential
            credentials.shuffle
        end while
        credential = credentials[0]
        
        parts = credential.split(":")
        id = parts[0].to_int
        password = parts[1]

        result = connectWirelessNetworkById(Intrinsics.computer, iface, networks, id, password)
        Console.log(Messages.LogConnectedToEssidSuccessfully, {"ESSID": getNetworkEssidById(networks, id)})
    end while
end function




////////////////////////////////////////////////////////////
// File session type
////////////////////////////////////////////////////////////

command "chdir", ["cd", "walk", "w"], Const.file, Messages.HelpEntryWalk, function(arguments)
    Conditions.arguments(arguments, 2)

    command = str(arguments[0])
    s = arguments[1]
    path = str(arguments[1])

    fd = Intrinsics.file

    if "back".indexOf(command) == 0 then
        if not s isa number then return Console.error(Messages.ErrorUnknownArguments)
        i = 0; while i < s; i = i + 1
            if fd.parent then fd = fd.parent
        end while
        Intrinsics.file = fd
    else if "into".indexOf(command) == 0 then
        fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)
        Intrinsics.file = fd
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if
end function


command "dir", ["ls", "look", "l"], Const.file, Messages.HelpEntryLook, function(arguments)
    lookOne = function(path)
        fd = Intrinsics.file
        fd = iterateToPath(fd, path)
        if not fd or not fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotDirectory)

        Console.log(replaceF(Messages.LogContentsOfPath, {"PATH": fd.path}))
        output = Messages.LookHeader
        contents = fd.get_folders + fd.get_files
        for f in contents
            if f.is_folder then 
                type = Messages.Folder
            else if f.is_binary then 
                type = Messages.Binary
            else
                type = Messages.Text
            end if
            permissions = f.permissions
            output = output+char(10)+[permissions[1:],f.owner,f.group,f.size,type,f.name].join(" ")
        end for
        if contents.len == 0 then output = output+char(10)+"- - - - - -"
        
        lines = output.split(char(10))
        namePredicate = function(iItem, jItem)
            iName = iItem.split(" ")[5]
            jName = jItem.split(" ")[5]
            return iName > jName
        end function
        ftPredicate = function(iItem, jItem)
            priority = {
                Messages.Folder: 2,
                Messages.Binary: 1,
                Messages.Text: 0,
            }
            iType = iItem.split(" ")[4]
            jType = jItem.split(" ")[4]
            return priority[iType] < priority[jType]
        end function
        mergeSort(lines, @namePredicate, 1)
        mergeSort(lines, @ftPredicate, 1)
        output = lines.join(char(10))

        output = formatColumnsColored(output, Theme.miscPrimary, Theme.miscSecondary)
        print(output)
    end function
    
    if arguments.len == 0 then
        lookOne(Intrinsics.file.path)
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            lookOne(path)
            print(" ")
        end for
        lookOne(last)
    end if
end function


command "more", [], Const.file, Messages.HelpEntryRead, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    readOne = function(path)
        fd = Intrinsics.file
        fd = iterateToPath(fd, path)
        if not fd or fd.is_binary or fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotTextFile)
        content = fd.get_content
        if content == null then return Console.error(Messages.ErrorCouldReadFile)
        Console.log(replaceF(Messages.LogContentsOfPath, {"PATH": fd.path}))
        lines = content.split(char(10))
        i = 0; while i < lines.len; i = i + 1
            line = escape(lines[i-1])
            print("<color="+Theme.miscSecondary+">"+str(i-1 + 1)+"</color><color="+Theme.miscPrimary+">:</color> "+line)
        end while
    end function

    if arguments.len == 1 then
        readOne(str(arguments[0]))
    else
        arguments = fmap(@str, arguments)
        last = arguments.pop
        for path in arguments
            readOne(path)
            print(" ")
        end for
        readOne(last)
    end if
end function


command "del", [], Const.file, Messages.HelpEntryDelete, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    deleteOne = function(path)
        fd = iterateToPath(Intrinsics.file, path)
        if not fd then return Console.error(Messages.ErrorPathDoesNotExist)
        if fd.is_folder then
            dirfds = fd.get_folders+fd.get_files
            areAllAccessible = true
            for dirfd in dirfds
                if not dirfd.has_permission("w") then
                    areAllAccessible = false
                    break
                end if
            end for
            if areAllAccessible then
                for dirfd in dirfds
                    desyncFix(0.02)
                    dirfd.delete
                end for
            end if
        end if
        desyncFix
        result = fd.delete
        if result != "" then return Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "delete", "ERROR": result}))
        Console.log(replaceF(Messages.LogFileDeletedSuccessfully, {"PATH": fd.path}))
    end function

    for path in fmap(@str, arguments)
        deleteOne(path)
    end for
end function


command "copy", ["cp"], Const.file, Messages.HelpEntryCopyNew, function(arguments)
    Conditions.argumentsMoreThan(arguments, 1)
    Conditions.argumentsFewerThan(arguments, 4)

    fd = Intrinsics.file
    path = str(arguments.pull)
    dest = str(arguments.pull)

    fdSource = iterateToPath(fd, path)
    if not fdSource then return Console.error(Messages.ErrorSourcePathDoesNotExist)
    fileName = str(arguments.pull)
    if not fileName then fileName = fdSource.name

    fdDest = iterateToPath(fd, dest)
    if not fdDest then return Console.error(Messages.ErrorDesinationPathDoesNotExist)

    result = fdSource.copy(fdDest.path, fileName)
    if result isa string then
        Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "copy", "ERROR": result}))
    else if not result then
        Console.error(Messages.ErrorUnknown)
    else
        Console.log(Messages.LogCopiedFileSuccessfully)
    end if
end function


command "tree", [], Const.file, Messages.HelpEntryTree, function(arguments)
    Conditions.arguments(arguments, 0)

    recursefd = function(fd, tab=2)
        print((" "*(tab-2))+"<color="+Theme.miscPrimary+">"+fd.permissions+"</color> "+"<color="+Theme.miscSecondary+">"+fd.path)
        for file in fd.get_files
            print((" "*tab)+"<color="+Theme.miscPrimary+">"+file.permissions+"</color> "+"<color="+Theme.miscSecondary+">"+file.path)
        end for
        for folder in fd.get_folders
            recursefd(folder, tab + 2)
        end for
    end function

    Console.log(Messages.LogFileSystemTree)
    fd = iterateToPath(Intrinsics.file, "/")
    recursefd(fd)
end function


command "move", ["mv"], Const.file, Messages.HelpEntryMoveNew, function(arguments)
    Conditions.argumentsMoreThan(arguments, 1)
    Conditions.argumentsFewerThan(arguments, 4)
    
    fd = Intrinsics.file
    path = str(arguments.pull)
    dest = str(arguments.pull)

    fdSource = iterateToPath(fd, path)
    if not fdSource then return Console.error(Messages.ErrorSourcePathDoesNotExist)
    fileName = str(arguments.pull)
    if not fileName then fileName = fdSource.name

    fdDest = iterateToPath(fd, dest)
    if not fdDest then return Console.error(Messages.ErrorDesinationPathDoesNotExist)

    result = fdSource.move(fdDest.path, fileName)
    if result isa string then
        Console.error(replaceF(Messages.ErrorStringGeneral, {"FUNC": "move", "ERROR": result}))
    else if not result then
        Console.error(Messages.ErrorUnknown)
    else
        Console.log(Messages.LogMovedFileSuccessfully)
    end if
end function


command "corrupt", [], Const.file, Messages.HelpEntryCorrupt, function(arguments)
    Conditions.arguments(arguments, 0)

    result = corruptLogs(Intrinsics.computer, Intrinsics.file)
    if not result then return Console.error(Messages.ErrorFailedLogCorruption)
    Console.log(Messages.LogSuccessfullLogCorruption)
end function


command "change", ["ch"], Const.file, Messages.HelpEntryChange, function(arguments)
    Conditions.arguments(arguments, 3)

    command = str(arguments[0])
    commandArg = str(arguments[1])
    path = str(arguments[2])

    fd = iterateToPath(Intrinsics.file, path)
    if not fd then return Console.error(Messages.ErrorPathDoesNotExist)

    if "mod".indexOf(command) == 0 then
        func = "chmod"
        result = fd.chmod(commandArg, true)
    else if "group".indexOf(command) == 0 then
        func = "set_group"
        result = fd.set_group(commandArg, true)
    else if "owner".indexOf(command) == 0 then
        func = "set_owner"
        result = fd.set_owner(commandArg, true)
    else
        return Console.error(Messages.ErrorUnknownArguments)
    end if

    if result and result isa string then
        Console.error(Messages.ErrorStringGeneral, {"FUNC": func, "ERROR": result})
    else if result != "" then
        Console.error(Messages.ErrorUnknown)
    else
        Console.log(Messages.LogSuccessStringGeneral)
    end if
end function


command "mari", [], Const.file, Messages.HelpEntryMari, function(arguments)
    Conditions.argumentsMoreThan(arguments, 0)

    mariOne = function(path)
        fd = iterateToPath(Intrinsics.file, path)
        if not fd or fd.is_binary or fd.is_folder then return Console.error(Messages.ErrorPathDoesntExistOrNotTextFile)
        if fd.get_content == null then return Console.error(Messages.ErrorCouldReadFile)

        Console.log(Messages.LogExecutingScript, {"NAME": fd.name})
        for line in fd.get_content.split(char(10))
            Console.interpretLine(line)
        end for
    end function

    for path in arguments
        mariOne(path)
    end for
end function
